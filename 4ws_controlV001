; 4WS Mobile Robot Control Script (Server Mode)
; 수정일: 2026-01-19
; 설명: Server Mode 동작 (Port 5009 Listen)
;       클라이언트로부터 "x,y,c" 형식의 문자열 수신 후 4WS 제어 수행

; =========================================================
; 설정 상수
; =========================================================
THRESHOLD = 1.0
STEER_SPOT = 45.0
SERVER_PORT = 5009

; 통신 변수
h_server = 0     ; 서버 소켓 핸들
h_client = 0     ; 클라이언트 소켓 핸들
comm_err = 0     ; 통신 에러 코드
$msg_in = ""     ; 수신 버퍼
$msg_out = ""    ; 송신 버퍼

; 초기화
in_x = 0.0
in_y = 0.0
in_c = 0.0

; =========================================================
; 1. 서버 시작 (Listen)
; =========================================================
server_init:
    TPWrite 2, "Server Starting on Port %d...", SERVER_PORT
    TCPSStart h_server, SERVER_PORT
    
    ; 소켓 생성 실패 시 (음수 반환)
    IF h_server < 0 THEN
        TPWrite 2, "Server Start Failed: %d", h_server
        WaitTime 1
        GOTO server_init
    END
    
    TPWrite 2, "Server Started. Waiting for Client...", 0

wait_client:
    ; 클라이언트 접속 대기
    TCPSAccept h_server, h_client
    
    IF h_client < 0 THEN
        ; 접속 대기 중 에러 또는 타임아웃 등
        WaitTime 0.1
        GOTO wait_client
    END
    
    TPWrite 2, "Client Connected! (Handle: %d)", h_client

; =========================================================
; 메인 루프 (데이터 수신 및 제어)
; =========================================================
loop_start:
    ; -----------------------------------------------------
    ; 2. 데이터 수신 (Watchdog 적용)
    ; -----------------------------------------------------
    $msg_in = ""
    ; TCPSRead Timeout=0.2s
    TCPSRead h_client, $msg_in, comm_err, 0.2

    ; (1) 연결 끊김 체크
    IF comm_err == 0 THEN
        TPWrite 2, "Client Disconnected", 0
        ; 안전 정지
        q_axis_1 = 0
        q_axis_2 = 0
        q_axis_3 = 0
        q_axis_4 = 0
        q_axis_5 = 0
        
        TCPSCClose h_client
        TCPSStop h_server
        GOTO server_init
    END

    ; (2) Watchdog 체크
    msg_len = Len($msg_in)
    IF msg_len == 0 THEN
        ; [Safety Stop]
        q_axis_1 = 0
        q_axis_2 = 0
        q_axis_3 = 0
        q_axis_4 = 0
        q_axis_5 = 0
        GOTO loop_start
    END

    ; -----------------------------------------------------
    ; 3. 데이터 파싱 ("accel,rf,rr,lf,lr;")
    ; -----------------------------------------------------
    ; 세미콜론(;)으로 패킷 분리 (Stickering 방지)
    SplitStr $cmds[0], $msg_in, ";"
    
    ; 첫 번째 완성된 패킷 사용 ($cmds[0])
    ; (만약 버퍼에 여러 개가 와도, 가장 앞의 유효한 것 처리. 
    ;  빠른 제어를 위해 마지막 것을 쓸 수도 있지만, 안정성을 위해 순차 처리 권장)
    
    $valid_cmd = $cmds[0]
    
    ; 유효성 체크 (빈 문자열이면 무시)
    cmd_len = Len($valid_cmd)
    IF cmd_len < 3 THEN
        GOTO loop_start
    END

    SplitStr $token[0], $valid_cmd, ","
    
    ; 5개 값 직접 수신
    in_accel = Value($token[0])
    in_rf    = Value($token[1])
    in_rr    = Value($token[2])
    in_lf    = Value($token[3])
    in_lr    = Value($token[4])

    ; -----------------------------------------------------
    ; 4. 하드웨어 출력 (Driver Mode)
    ; -----------------------------------------------------
    ; 상위 제어기에서 계산된 각도를 그대로 적용  MoveJ 로 명령 출력
    
    q_axis_1 = in_accel  ; Accel / Valve
    q_axis_2 = in_rf     ; RF Steer
    q_axis_3 = in_rr     ; RR Steer
    q_axis_4 = in_lf     ; LF Steer
    q_axis_5 = in_lr     ; LR Steer
    
    ; 4-1. 하드웨어 구동 (Motion)
    Point #pmobile = Joint(q_axis_1, q_axis_2, q_axis_3, q_axis_4, q_axis_5)
    MoveJ #pmobile

    
    ; -----------------------------------------------------
    ; 5. 상태 송신 (Feedback) - Binary with Header (0xFEFE)
    ; -----------------------------------------------------
    ; Header: 0xFEFE (65278)
    $msg_out = $Int16B(65278)
    
    ; 1. Accel
    val_int = Int(q_axis_1 * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n1
    IF val_lo == 0 GOTO skip_n1
        val_hi = val_hi - 1
skip_n1:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 2. RF
    val_int = Int(q_axis_2 * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n2
    IF val_lo == 0 GOTO skip_n2
        val_hi = val_hi - 1
skip_n2:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 3. RR
    val_int = Int(q_axis_3 * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n3
    IF val_lo == 0 GOTO skip_n3
        val_hi = val_hi - 1
skip_n3:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 4. LF
    val_int = Int(q_axis_4 * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n4
    IF val_lo == 0 GOTO skip_n4
        val_hi = val_hi - 1
skip_n4:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 5. LR
    val_int = Int(q_axis_5 * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n5
    IF val_lo == 0 GOTO skip_n5
        val_hi = val_hi - 1
skip_n5:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 6. Error
    val_int = comm_err
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    TCPSWrite h_client, $msg_out

    GOTO loop_start
