; 4WS Server Task (Communication Only)
; 작성일: 2026-02-04
; 설명: 클라이언트와 통신하여 제어 명령을 수신하고 글로벌 변수에 저장
;       Motion Task가 이 글로벌 변수를 참조하여 로봇을 구동함

; =========================================================
; 설정 상수
; =========================================================
SERVER_PORT = 5009

; 통신 변수
h_server = 0
h_client = 0
g_comm_err = 0     ; Shared Error Code
$msg_in = ""
$msg_out = ""

; =========================================================
; 글로벌 변수 초기화 (Motion Task와 공유)
; =========================================================
g_in_accel = 0.0
g_in_rf    = 0.0
g_in_rr    = 0.0
g_in_lf    = 0.0
g_in_lr    = 0.0

; =========================================================
; 1. 서버 시작
; =========================================================
server_init:
    TPWrite 2, "[ServerTask] Starting on Port %d...", SERVER_PORT
    TCPSStart h_server, SERVER_PORT
    
    IF h_server < 0 THEN
        TPWrite 2, "[ServerTask] Start Failed: %d", h_server
        WaitTime 1
        GOTO server_init
    END
    
    TPWrite 2, "[ServerTask] Waiting for Client...", 0

wait_client:
    TCPSAccept h_server, h_client
    
    IF h_client < 0 THEN
        WaitTime 0.1
        GOTO wait_client
    END
    
    TPWrite 2, "[ServerTask] Client Connected! (Handle: %d)", h_client

; =========================================================
; 메인 루프 (데이터 수신 및 송신)
; =========================================================
loop_start:
    ; -----------------------------------------------------
    ; 2. 데이터 수신
    ; -----------------------------------------------------
    $msg_in = ""
    TCPSRead h_client, $msg_in, g_comm_err, 0.05 ; Fast Timeout

    ; (1) 연결 끊김 체크
    IF g_comm_err == 0 THEN
        TPWrite 2, "[ServerTask] Client Disconnected", 0
        ; 안전 정지 값 설정
        g_in_accel = 0.0
        g_in_rf = 0.0
        g_in_rr = 0.0
        g_in_lf = 0.0
        g_in_lr = 0.0
        
        TCPSCClose h_client
        TCPSStop h_server
        GOTO server_init
    END

    ; (2) Watchdog / 데이터 파싱
    msg_len = Len($msg_in)
    IF msg_len >= 3 THEN
        ; 세미콜론(;)으로 패킷 분리 (Stickering 방지)
        SplitStr $cmds[0], $msg_in, ";"
        $valid_cmd = $cmds[0]
        
        IF Len($valid_cmd) >= 3 THEN
            SplitStr $token[0], $valid_cmd, ","
            ; Client Format: "accel,rf,rr,lf,lr"
            g_in_accel = Value($token[0])
            g_in_rf    = Value($token[1])
            g_in_rr    = Value($token[2])
            g_in_lf    = Value($token[3])
            g_in_lr    = Value($token[4])
        END
    END

    ; -----------------------------------------------------
    ; 3. 상태 송신 (Binary with Header 0xFEFE)
    ; -----------------------------------------------------
    ; [Feedback] Actual Robot Position Reading
    ; CurJ로 현재 관절 좌표를 읽어서 전송 (단, 1번축은 유압이라 다를 수 있음 확인 필요)
    Point #p_curr = CurJ
    fb_accel = GetJ(#p_curr, 1)
    fb_rf    = GetJ(#p_curr, 2)
    fb_rr    = GetJ(#p_curr, 3)
    fb_lf    = GetJ(#p_curr, 4)
    fb_lr    = GetJ(#p_curr, 5)

    ; Header: 0xFEFE (65278)
    $msg_out = $Int16B(65278)
    
    ; 1. Accel
    val_int = Int(fb_accel * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n1
    IF val_lo == 0 GOTO skip_n1
        val_hi = val_hi - 1
skip_n1:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 2. RF
    val_int = Int(fb_rf * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n2
    IF val_lo == 0 GOTO skip_n2
        val_hi = val_hi - 1
skip_n2:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 3. RR
    val_int = Int(fb_rr * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n3
    IF val_lo == 0 GOTO skip_n3
        val_hi = val_hi - 1
skip_n3:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 4. LF
    val_int = Int(fb_lf * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n4
    IF val_lo == 0 GOTO skip_n4
        val_hi = val_hi - 1
skip_n4:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 5. LR
    val_int = Int(fb_lr * 100)
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    IF val_int >= 0 GOTO skip_n5
    IF val_lo == 0 GOTO skip_n5
        val_hi = val_hi - 1
skip_n5:
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    ; 6. Error
    ; TCPSRead가 Timeout(-1)일 경우 UI에 65535로 표시되는 문제 해결
    ; Timeout은 정상 대기 상태이므로 0으로 전송
    IF g_comm_err < 0 THEN
        val_int = 0
    ELSE
        val_int = g_comm_err
    END
    
    val_hi = Int(val_int / 65536)
    val_lo = val_int - (val_hi * 65536)
    $msg_out = $msg_out + $Int16B(val_hi) + $Int16B(val_lo)
    
    TCPSWrite h_client, $msg_out

    WaitTime 0.01 ; 100Hz Update for Comm
    GOTO loop_start
